\chapter{The realizability interpretation of logic}\label{chap:logic}

\section{Categorical logic in a nutshell}

\cite{Lawvere1969}

\section{Categorical logic in categories of assemblies}

\textcolor{Mulberry}{TODO: Intro}

\begin{definition}[\(\PA\)-valued predicate]
  For a pca \(\AA\), a \textbf{\(\PA\)-valued predicate} on a set \(X\) is a
  function \(X \to \PA\).
\end{definition}

\begin{notation}
  We will typically use lowercase Greek letters \(\phi,\psi,\sigma,\rho,\tau\),
  etc.\ for \(\PA\)-valued predicates.
\end{notation}

Given \(\phi \colon X \to \PA\), we think of \(\phi\) as a logical predicate on
\(X\), and of \(\phi(x)\) as the set of witnesses that \(\phi\) holds for the
element \(x\).

\begin{definition}[Preorder on \(\PA\)-valued predicates, \(\phi \predleq \psi\)]
  For two \(\PA\)-valued predicates \(\phi\) and \(\psi\) on the same set \(X\),
  we put
  \[
    \phi \predleq \psi \iff
    \exists(\pca{r} \in \pca{\AA}).
    \forall (x \in X).\forall(\pca{a} \in \phi(x)).\pca{r}\pca{a} \in \psi(x),
  \]
  where we implicitly include the requirement that \(\pca{r}\pca{a}\) is defined.
\end{definition}

Intuitively, we have \(\phi \predleq \psi\) exactly if we can effectively
calculate a witness that \(\psi\) holds at \(x\) form a witness that \(\phi\)
holds at \(x\).
%
It is straightforward (and very similar to checking that assemblies and assembly
maps form a category) to check that \(\predleq\) is indeed a preorder, i.e.\
that it is a reflexive and transitive relation.

Every monomorphism \(m \colon Y \hookrightarrow X\) on an assembly \(X\)
determines a \(\PA\)-valued predicate \(\phi_m\) on \(\carrier{X}\) by:
\[
  \phi_m(x) \coloneqq \set{\pca{a} \in \AA \mid
    \exists(y \in \carrier{Y}).\pca{a} \realizes_Y y \text{ and } m(y) = x}.
\]
%
Notice that the \(y \in \carrier{Y}\) is necessarily unique (if it exists),
because \(m\) is injective.

Conversely, every \(\PA\)-valued predicate on \(\carrier{X}\) determines a
monomorphism \([\phi] \hookrightarrow X\) via:
\begin{align*}
  \carrier{[\phi]} \coloneqq \set{x \in \carrier{X} \mid \phi(x) \text{ is inhabited}} \\
  \pcapair\pca{a}\pca{b} \realizes_{[\phi]} x
  \iff \pca{a} \realizes_X x
  \text{ and }
  \pca{b} \in \phi(x),
\end{align*}
where the inclusion \([\phi] \hookrightarrow X\) is tracked by \(\pcafst\).

\begin{proposition}
  For any assembly \(X\), the above constructions constitute an isomorphism
  between the preorder of monomorphisms into \(X\) and the preorder of
  \(\PA\)-valued predicates on \(\carrier{X}\).
\end{proposition}
\begin{exercise}\label{exer:preorders-monos-predicates-iso}
  Prove the proposition.
\end{exercise}


\subsection{Logical connectives}


\section{Revisiting (regular) monos and epis}

\begin{exercise}\label{exer:epis-monos-logically}
  Prove the following logical characterizations for any assembly map \(f \colon X \to Y\):
  \begin{enumerate}[(i)]
  \item \(f\) is a regular epimorphism if and only if
    \[
      \forall(x : X).\exists(y : Y).f(x) = y
    \]
    is realized;
  \item \(f\) is an epimorphism if and only if
    \[
      \forall(x : X).\lnot\lnot({\exists(y : Y).f(x) = y})
    \]
    is realized;
  \item \(f\) is a monomorphism if and only if
    \[
      \forall(x, x' : X).(f(x) = f(x') \Rightarrow x = x')
    \]
    is realized;
  \item \(f\) is a regular monomorphism if and only if
    \[
      \forall(y : Y).\pa*{\lnot\lnot\pa*{\exists(x : X).f(x) = y} \Rightarrow \exists!(x : X).f(x) = y}
    \]
    is realized.

    The quantifier \(\exists!\) means ``there exists a unique \dots with \dots''.

    Phrased in English, \(f\) is a regular monomorphism if and only if the statement
    \begin{quote}{``For all \(y\), if the primage of \(f\) at \(y\) is nonempty,
        then we can (effectively) find a unique \(x\) with \(f(x) = y\).''}
    \end{quote}
    is realized.
  \end{enumerate}
\end{exercise}

The \(\lnot\lnot\)-stable predicates have no computational content as made
precise by the following exercise:

\begin{exercise}\label{exer:not-not-stable-nabla-pullback}
  Show that every \(\lnot\lnot\)-stable predicate \(\phi\) on an assembly \(X\)
  is uniquely determined by a subset \(A \subseteq \carrier{X}\) such that we
  have a pullback diagram
  \[
    \begin{tikzcd}
      {[\phi]} \ar[r] \ar[d,hookrightarrow] \pbcorner
      & \nabla A \ar[d,hookrightarrow] \\
      X \ar[r,"\eta_X"] & \nabla\carrier{X}
    \end{tikzcd}
  \]
  in \(\Asm{\AA}\), where we recall that \([\phi] \hookrightarrow X\) denotes
  the mono corresponding to \(\phi\).
\end{exercise}

In fact, because subsets are uniquely determined (again, via pullback) by their
characteristic function, we have:

\begin{exercise}\label{exer:not-not-stable-nabla-two-pullback}
  Show that every \(\lnot\lnot\)-stable predicate \(\phi\) on an assembly \(X\)
  is uniquely determined by a map \(\chi \colon X \to \nabla\set{0,1}\) such
  that we have a pullback diagram
  \[
    \begin{tikzcd}
      {[\phi]} \ar[r] \ar[d,hookrightarrow] \pbcorner
      & 1 \ar[d,hookrightarrow,"{\singleton \,\mapsto\, 1}"] \\
      X \ar[r,"\chi"] & \nabla\set{0,1}
    \end{tikzcd}
  \]
  in \(\Asm{\AA}\).
\end{exercise}

The map \(1 \to \nabla\set{0,1}\) is said to be a \textbf{classifier} for the
\(\lnot\lnot\)-stable predicates (subobjects).

\section{List of exercises}
\begin{enumerate}
\item \cref{exer:preorders-monos-predicates-iso}: On monomorphisms as
  \(\PA\)-valued predicates.
\item \cref{exer:epis-monos-logically}: On logical characterizations of
  (regular) epimorphisms and monomorphisms.
\item \cref{exer:not-not-stable-nabla-two-pullback}: On the correspondence
  between \(\lnot\lnot\)-stable predicates and subsets.
\item \cref{exer:not-not-stable-nabla-two-pullback}: On the classifier for
  \(\lnot\lnot\)-stable predicates.
\end{enumerate}

%%% Local Variables:
%%% mode: latexmk
%%% TeX-master: "../main"
%%% End:
