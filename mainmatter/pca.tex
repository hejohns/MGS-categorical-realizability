\chapter[Models of computation: partial combinatory algebras]{Models of computation: \\ partial combinatory algebras}\label{chap:PCA}

\textcolor{Mulberry}{TODO: Introduction, general model of computation, mention
  typed vs untyped}

\begin{definition}[Partial combinatory algebra (pca), \(\kcomb\), \(\scomb\)]\label{def:pca}
  A \textbf{partial combinatory algebra} (\textbf{pca}) is a set \(\AA\) together with a \emph{partial}
  operation \(\AA \times \AA \pto \AA\), denoted by juxtaposition,
  \((\pca{a},\pca{b}) \mapsto \pca{a}\pca{b}\), such that there exist elements \(\kcomb\) and \(\scomb\)
  satisfying:
  \begin{enumerate}[(i)]
  \item\label{k-behaviour} \((\kcomb \pca{a}) \pca{b} = \pca{a}\) for all elements
    \(\pca{a},\pca{b} \in \AA\),
  \item\label{s-defined} \(((\scomb \pca{f}) \pca{g})\) is defined for all elements
    \(\pca{f},\pca{g} \in \AA\), and
  \item\label{s-behaviour}
    \(((\scomb \pca{f}) \pca{g}) \pca{a} \simeq
    (\pca{f}\pca{a})(\pca{g}\pca{a})\) for all elements
    \(\pca{f},\pca{g},\pca{a} \in \AA\).
  \end{enumerate}
  The symbol \(\simeq\) is \emph{Kleene equality} and means: either both sides
  are undefined, or both are defined and are equal elements of \(\AA\).
  %
  In particular, in~\ref{k-behaviour}, the operation \(\kcomb\pca{a}\) must be
  defined for all elements \(\pca{a} \in \AA\).
\end{definition}

We think of the elements of a pca as codes for programs that can also act as
input. Accordingly, we pronounce \(\pca{a}\pca{b}\) as ``\(\pca{a}\) applied to
\(\pca{b}\)'' and think of this as: apply the program with code \(\pca{a}\) to
input \(\pca{b}\).

In this light, the element \(\kcomb\), which we call the \emph{k-combinator}, act
as a parameterised constant program: it takes an input \(\pca{a}\) and then
always outputs \(\pca{a}\) on any input \(\pca{b}\).

The element \(\scomb\), which we call the \emph{s-combinator}\footnote{The
  letters \emph{k} and \emph{s} come from Moses Sch\"onfinkel's combinatory
  logic~\cite{Schonfinkel1924}. They respectively come from the German words
  \emph{Konstanzfunktion} (constant function) and \emph{Verschmelzungfunktion}
  (merge function). Of course, \emph{Verschmelzungsfunktion} starts with a
  \emph{v}, but Sch\"onfinkel had to avoid confusion as there was also a
  swap-arguments combinator called the \emph{Vertauschungsfunktion}.}, act as
parameterised application: it takes two codes for programs \(\pca{f}\) and
\(\pca{g}\) and an input \(\pca{a}\) and then applies \(\pca{f}\pca{a}\) to
\(\pca{g}\pca{a}\).

\begin{notation}
  We will economise on parentheses and write \(\pca{a}\pca{b}\pca{c}\) for
  \((\pca{a}\pca{b})\pca{c}\).
  %
  We will always use the \texttt{teletype font} for arbitrary elements of a pca
  to reinforce the idea that these should be thought of as (codes of) programs.
\end{notation}

The point of the k- and s-combinators is that they provide us with a (very
minimal) programming interface which we will explore in~\cref{TODO}.
%
We prefer to give two examples first to strengthen our intuition for pcas.

\section{Basic examples}

\begin{example}[Untyped \(\lambda\)-calculus as a pca, \(\Lambda\)]
  Write \(\Lambda\) for the closed terms of the untyped \(\lambda\)-calculus
  quotiented by the equivalence relation generated by
  \(\beta\)-reduction. (E.g., for a closed \(\lambda\)-term \(t\), we identify
  \((\lambda{x}.{x})t\) and \(t\).)
  %
  With \(\lambda\)-calculus application the set \(\Lambda\) forms a pca with the
  k- and s-combinators given by \(\kcomb \coloneq \lambda{xy}.x\) and
  \(\scomb \coloneq \lambda{xyz}.(xz)(yz)\).
\end{example}

The application function of \(\Lambda\) is actually total, i.e.\ it is defined
on any two inputs. An example of a pca with a genuine partial application---which
is also the prime example of a pca---is \emph{Kleene's first model}~\cite{Kleene1945}:

\begin{example}[Kleene's first model, \(\Kone\)]
  We define a partial application function on the set of natural numbers
  \(\Nat\): for natural numbers \(n\) and \(m\) we take \(n\,m\) to be
  \(\prenum{n}(m)\), where \(\prenum{-}\) denotes a Turing computable
  enumeration of the Turing computable partial functions on the natural numbers.

  The existence of the k- and s-combinators follows from Kleene's
  \(S^m_n\)-theorem in computability theory, see e.g.~\cite[Section~2.5.1 and
  Theorem~2.1.5]{Bauer2023} for details.

  We write \(\Kone\) for this partial combinatory algebra and we will return to
  it in~\cref{chap:logic,chap:synthetic}.
\end{example}

\section{Basic programming}

As previously mentioned, the k- and s-combinators of a pca \(\AA\) give us an
interface for writing basic programs. For example, if we define\footnote{Note
  that this indeed defines an element of \(\AA\)
  by~\cref{def:pca}\ref{s-defined}.}
\(\icomb \coloneq \scomb\,\kcomb\,\kcomb\) then \(\icomb\) acts as the
identity combinator:
\[
  \icomb\pca{a} = \scomb\,\kcomb\,\kcomb\pca{a} = \kcomb\pca{a}(\kcomb\pca{a}) =
  {\pca{a}}.
\]

While theoretically possible, it is very inconvenient to program everything
directly in terms of \(\kcomb\) and \(\scomb\). It is possible, however, to
define something resembling \(\lambda\)-abstraction for our pca, allowing us to
write the clearer \(\icomb \coloneq \lambdapca{x}{\var{x}}\) instead.

\textcolor{Mulberry}{Define terms, notation for substitution, combinatory completeness}

\begin{exercise}\label{exer:test-exercise}
  Show something...
\end{exercise}


\section{Topological examples}
\cite{Scott1976}
\cite{KleeneVesley1965}

\section{List of exercises}
\begin{enumerate}
\item \cref{exer:test-exercise}: On relating...
\end{enumerate}




%%% Local Variables:
%%% mode: latexmk
%%% TeX-master: "../main"
%%% End:
